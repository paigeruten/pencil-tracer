// Generated by CoffeeScript 1.9.2
(function() {
  var InstrumentError,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  InstrumentError = (function(superClass) {
    extend(InstrumentError, superClass);

    function InstrumentError(message) {
      this.message = message;
      this.name = "InstrumentError";
      Error.call(this);
      Error.captureStackTrace(this, arguments.callee);
    }

    return InstrumentError;

  })(Error);

  exports.CoffeeScriptInstrumenter = (function() {
    function CoffeeScriptInstrumenter(coffee) {
      this.coffee = coffee;
      if (this.coffee == null) {
        this.coffee = require("coffee-script");
      }
    }

    CoffeeScriptInstrumenter.prototype.nodeType = function(node) {
      var ref;
      return (node != null ? (ref = node.constructor) != null ? ref.name : void 0 : void 0) || null;
    };

    CoffeeScriptInstrumenter.prototype.makeUndefinedNode = function() {
      return this.coffee.nodes("undefined").expressions[0];
    };

    CoffeeScriptInstrumenter.prototype.makeAssignNode = function(variableName, valueNode) {
      var node;
      node = this.coffee.nodes("x = 0").expressions[0];
      node.variable.base.value = variableName;
      node.value = valueNode;
      return node;
    };

    CoffeeScriptInstrumenter.prototype.makeReturnNode = function(variableName) {
      var node;
      node = this.coffee.nodes("return x").expressions[0];
      node.expression.base.value = variableName;
      return node;
    };

    CoffeeScriptInstrumenter.prototype.fixLocationData = function(instrumentedNode, lineNum) {
      var doIt;
      doIt = function(node) {
        return node.locationData = {
          first_line: lineNum,
          first_column: 0,
          last_line: lineNum,
          last_column: 0
        };
      };
      doIt(instrumentedNode);
      return instrumentedNode.eachChild(doIt);
    };

    CoffeeScriptInstrumenter.prototype.createInstrumentedNode = function(traceFunc, locationData, eventType) {
      var instrumentedNode, locationObj;
      locationObj = "{ first_line: " + (locationData.first_line + 1) + ",";
      locationObj += " first_column: " + (locationData.first_column + 1) + ",";
      locationObj += " last_line: " + (locationData.last_line + 1) + ",";
      locationObj += " last_column: " + (locationData.last_column + 1) + " }";
      instrumentedNode = this.coffee.nodes(traceFunc + "({ location: " + locationObj + ", type: '" + eventType + "' })");
      this.fixLocationData(instrumentedNode, locationData.first_line);
      return instrumentedNode;
    };

    CoffeeScriptInstrumenter.prototype.temporaryVariable = function(name, used) {
      var curName, index;
      index = 0;
      while (true) {
        curName = "" + name + index;
        if (indexOf.call(used, curName) < 0) {
          return curName;
        }
        index++;
      }
    };

    CoffeeScriptInstrumenter.prototype.instrument = function(filename, code, options) {
      var ast, err, instrumentTree, js, ref, referencedVars, token, tokens, traceFunc;
      if (options == null) {
        options = {};
      }
      traceFunc = (ref = options.traceFunc) != null ? ref : "pencilTrace";
      try {
        tokens = this.coffee.tokens(code, {});
        referencedVars = (function() {
          var i, len, results;
          results = [];
          for (i = 0, len = tokens.length; i < len; i++) {
            token = tokens[i];
            if (token.variable) {
              results.push(token[1]);
            }
          }
          return results;
        })();
        ast = this.coffee.nodes(tokens);
      } catch (_error) {
        err = _error;
        throw new InstrumentError("Could not parse " + filename + ": " + err.stack);
      }
      instrumentTree = (function(_this) {
        return function(node, nodeIndex, parent, inCode) {
          var assignNode, childIndex, children, expression, instrumentedNode, lastExpr, tempVariableName;
          if (nodeIndex == null) {
            nodeIndex = null;
          }
          if (parent == null) {
            parent = null;
          }
          if (inCode == null) {
            inCode = null;
          }
          if (_this.nodeType(node) === "Code") {
            inCode = node;
          }
          if (_this.nodeType(node) === "Block") {
            children = node.expressions;
            childIndex = 0;
            while (childIndex < children.length) {
              expression = children[childIndex];
              if (!(expression.doNotInstrument || _this.nodeType(expression) === "Comment")) {
                instrumentedNode = _this.createInstrumentedNode(traceFunc, expression.locationData, "");
                children.splice(childIndex, 0, instrumentedNode);
                childIndex++;
                instrumentTree(expression, childIndex, node, inCode);
              }
              childIndex++;
            }
            if (_this.nodeType(parent) === "Code") {
              children.splice(0, 0, _this.createInstrumentedNode(traceFunc, parent.locationData, "enter"));
              if (children.length === 1) {
                children.splice(1, 0, _this.createInstrumentedNode(traceFunc, parent.locationData, "leave"));
                return children.splice(2, 0, _this.makeUndefinedNode());
              } else {
                lastExpr = children[children.length - 1];
                if (_this.nodeType(lastExpr) !== "Return") {
                  tempVariableName = _this.temporaryVariable("_tempReturnVal", referencedVars);
                  referencedVars.push(tempVariableName);
                  assignNode = _this.makeAssignNode(tempVariableName, lastExpr);
                  children.splice(children.length - 1, 1, assignNode);
                  children.splice(children.length, 0, _this.createInstrumentedNode(traceFunc, parent.locationData, "leave"));
                  return children.splice(children.length, 0, _this.coffee.nodes(tempVariableName).expressions[0]);
                }
              }
            }
          } else {
            if (_this.nodeType(node) === "Return" && (inCode != null)) {
              if (_this.nodeType(parent) !== "Block") {
                throw new InstrumentError("Encountered a Return whose parent is not a Block. This is a bug, please report!");
              }
              tempVariableName = _this.temporaryVariable("_tempReturnVal", referencedVars);
              referencedVars.push(tempVariableName);
              assignNode = _this.makeAssignNode(tempVariableName, node.expression);
              parent.expressions.splice(nodeIndex, 1, assignNode);
              parent.expressions.splice(nodeIndex + 1, 0, _this.createInstrumentedNode(traceFunc, inCode.locationData, "leave"));
              parent.expressions.splice(nodeIndex + 2, 0, _this.makeReturnNode(tempVariableName));
              parent.expressions[nodeIndex].doNotInstrument = true;
              parent.expressions[nodeIndex + 1].doNotInstrument = true;
              parent.expressions[nodeIndex + 2].doNotInstrument = true;
            }
            return node.eachChild(function(child) {
              return instrumentTree(child, null, node, inCode);
            });
          }
        };
      })(this);
      instrumentTree(ast);
      if (options.ast) {
        return ast;
      }
      try {
        js = ast.compile({});
      } catch (_error) {
        err = _error;
        throw new InstrumentError("Could not compile " + filename + " after instrumenting: " + err.stack);
      }
      return js;
    };

    return CoffeeScriptInstrumenter;

  })();

}).call(this);
